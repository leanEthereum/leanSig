use core::array;

use p3_field::PackedValue;

use crate::{F, PackedF, array::FieldArray};

/// Packs scalar arrays into SIMD-friendly vertical layout.
///
/// Transposes from horizontal layout `[FieldArray<N>; WIDTH]` to vertical layout `[PackedF; N]`.
///
/// Input layout (horizontal): each FieldArray is one complete array
/// ```text
/// data[0] = FieldArray([a0, a1, a2, ..., aN])
/// data[1] = FieldArray([b0, b1, b2, ..., bN])
/// data[2] = FieldArray([c0, c1, c2, ..., cN])
/// ...
/// ```
///
/// Output layout (vertical): each PackedF holds one element from each array
/// ```text
/// result[0] = PackedF([a0, b0, c0, ...])  // All first elements
/// result[1] = PackedF([a1, b1, c1, ...])  // All second elements
/// result[2] = PackedF([a2, b2, c2, ...])  // All third elements
/// ...
/// ```
///
/// This vertical packing enables efficient SIMD operations where a single instruction
/// processes the same element position across multiple arrays simultaneously.
#[inline]
pub fn pack_array<const N: usize>(data: &[FieldArray<N>]) -> [PackedF; N] {
    array::from_fn(|i| PackedF::from_fn(|j| data[j][i]))
}

/// Unpacks SIMD vertical layout back into scalar arrays.
///
/// Transposes from vertical layout `[PackedF; N]` to horizontal layout `[FieldArray<N>; WIDTH]`.
///
/// This is the inverse operation of `pack_array`. The output buffer must be preallocated
/// with size `[WIDTH]` where `WIDTH = PackedF::WIDTH`, and each element is a `FieldArray<N>`.
#[inline]
pub fn unpack_array<const N: usize>(packed_data: &[PackedF; N], output: &mut [FieldArray<N>]) {
    // Optimized for cache locality: iterate over output lanes first
    for j in 0..PackedF::WIDTH {
        for i in 0..N {
            output[j].0[i] = packed_data[i].as_slice()[j];
        }
    }
}

/// Pack even-indexed FieldArrays (stride 2) directly into destination.
///
/// Packs `data[0], data[2], data[4], ...` into `dest[offset..offset+N]`.
/// Useful for packing left children from interleaved `[L0, R0, L1, R1, ...]` pairs.
///
/// # Arguments
/// * `dest` - Destination slice to pack into
/// * `offset` - Starting index in `dest`
/// * `data` - Source slice of interleaved pairs (must have length >= 2 * WIDTH)
#[inline]
pub fn pack_even_into<const N: usize>(dest: &mut [PackedF], offset: usize, data: &[FieldArray<N>]) {
    for i in 0..N {
        dest[offset + i] = PackedF::from_fn(|lane| data[2 * lane][i]);
    }
}

/// Pack odd-indexed FieldArrays (stride 2) directly into destination.
///
/// Packs `data[1], data[3], data[5], ...` into `dest[offset..offset+N]`.
/// Useful for packing right children from interleaved `[L0, R0, L1, R1, ...]` pairs.
///
/// # Arguments
/// * `dest` - Destination slice to pack into
/// * `offset` - Starting index in `dest`
/// * `data` - Source slice of interleaved pairs (must have length >= 2 * WIDTH)
#[inline]
pub fn pack_odd_into<const N: usize>(dest: &mut [PackedF], offset: usize, data: &[FieldArray<N>]) {
    for i in 0..N {
        dest[offset + i] = PackedF::from_fn(|lane| data[2 * lane + 1][i]);
    }
}

/// Pack values generated by a function directly into destination.
///
/// For each element index `i` in `0..N`, generates a PackedF by calling
/// `f(i, lane)` for each SIMD lane.
///
/// # Arguments
/// * `dest` - Destination slice to pack into
/// * `offset` - Starting index in `dest`
/// * `f` - Function that takes (element_index, lane_index) and returns a field element
#[inline]
pub fn pack_fn_into<const N: usize>(
    dest: &mut [PackedF],
    offset: usize,
    f: impl Fn(usize, usize) -> F,
) {
    for i in 0..N {
        dest[offset + i] = PackedF::from_fn(|lane| f(i, lane));
    }
}

#[cfg(test)]
mod tests {
    use crate::F;

    use super::*;
    use p3_field::PrimeCharacteristicRing;
    use proptest::prelude::*;
    use rand::Rng;

    #[test]
    fn test_pack_array_simple() {
        // Test with N=2 (2 field elements per array)
        // Create WIDTH arrays wrapped in FieldArray
        let data: [FieldArray<2>; PackedF::WIDTH] =
            array::from_fn(|i| FieldArray([F::from_u64(i as u64), F::from_u64((i + 100) as u64)]));

        let packed = pack_array(&data);

        // Check that packed[0] contains all first elements
        for (lane, expected) in data.iter().enumerate() {
            assert_eq!(packed[0].as_slice()[lane], expected[0]);
        }

        // Check that packed[1] contains all second elements
        for (lane, expected) in data.iter().enumerate() {
            assert_eq!(packed[1].as_slice()[lane], expected[1]);
        }
    }

    #[test]
    fn test_unpack_array_simple() {
        // Create packed data
        let packed: [PackedF; 2] = [
            PackedF::from_fn(|i| F::from_u64(i as u64)),
            PackedF::from_fn(|i| F::from_u64((i + 100) as u64)),
        ];

        // Unpack
        let mut output = [FieldArray([F::ZERO; 2]); PackedF::WIDTH];
        unpack_array(&packed, &mut output);

        // Verify
        for (lane, arr) in output.iter().enumerate() {
            assert_eq!(arr[0], F::from_u64(lane as u64));
            assert_eq!(arr[1], F::from_u64((lane + 100) as u64));
        }
    }

    #[test]
    fn test_pack_preserves_element_order() {
        // Create data where each array has sequential values
        let data: [FieldArray<3>; PackedF::WIDTH] = array::from_fn(|i| {
            FieldArray([
                F::from_u64((i * 3) as u64),
                F::from_u64((i * 3 + 1) as u64),
                F::from_u64((i * 3 + 2) as u64),
            ])
        });

        let packed = pack_array(&data);

        // Verify the packing structure
        // packed[0] should contain: [0, 3, 6, 9, ...]
        // packed[1] should contain: [1, 4, 7, 10, ...]
        // packed[2] should contain: [2, 5, 8, 11, ...]
        for (element_idx, p) in packed.iter().enumerate() {
            for lane in 0..PackedF::WIDTH {
                let expected = F::from_u64((lane * 3 + element_idx) as u64);
                assert_eq!(p.as_slice()[lane], expected);
            }
        }
    }

    #[test]
    fn test_unpack_preserves_element_order() {
        // Create packed data with known pattern
        let packed: [PackedF; 3] = [
            PackedF::from_fn(|i| F::from_u64((i * 3) as u64)),
            PackedF::from_fn(|i| F::from_u64((i * 3 + 1) as u64)),
            PackedF::from_fn(|i| F::from_u64((i * 3 + 2) as u64)),
        ];

        let mut output = [FieldArray([F::ZERO; 3]); PackedF::WIDTH];
        unpack_array(&packed, &mut output);

        // Verify each array has sequential values
        for (lane, arr) in output.iter().enumerate() {
            assert_eq!(arr[0], F::from_u64((lane * 3) as u64));
            assert_eq!(arr[1], F::from_u64((lane * 3 + 1) as u64));
            assert_eq!(arr[2], F::from_u64((lane * 3 + 2) as u64));
        }
    }

    proptest! {
        #[test]
        fn proptest_pack_unpack_roundtrip(
            _seed in any::<u64>()
        ) {
            let mut rng = rand::rng();

            // Generate random data with N=10, using FieldArray
            let original: [FieldArray<10>; PackedF::WIDTH] = array::from_fn(|_| {
                FieldArray(array::from_fn(|_| rng.random()))
            });

            // Pack and unpack
            let packed = pack_array(&original);
            let mut unpacked = [FieldArray([F::ZERO; 10]); PackedF::WIDTH];
            unpack_array(&packed, &mut unpacked);

            // Verify roundtrip
            prop_assert_eq!(original, unpacked);
        }

        #[test]
        fn proptest_pack_even_odd_into(
            _seed in any::<u64>()
        ) {
            let mut rng = rand::rng();

            // Generate interleaved pairs: [L0, R0, L1, R1, ...]
            let pairs: [FieldArray<5>; 2 * PackedF::WIDTH] = array::from_fn(|_| {
                FieldArray(array::from_fn(|_| rng.random()))
            });

            // Pack even (left children) and odd (right children)
            let mut dest = [PackedF::ZERO; 12];
            pack_even_into(&mut dest, 1, &pairs);
            pack_odd_into(&mut dest, 6, &pairs);

            // Verify even indices were packed correctly
            for i in 0..5 {
                for lane in 0..PackedF::WIDTH {
                    prop_assert_eq!(
                        dest[1 + i].as_slice()[lane],
                        pairs[2 * lane][i],
                        "Even packing mismatch at element {}, lane {}", i, lane
                    );
                }
            }

            // Verify odd indices were packed correctly
            for i in 0..5 {
                for lane in 0..PackedF::WIDTH {
                    prop_assert_eq!(
                        dest[6 + i].as_slice()[lane],
                        pairs[2 * lane + 1][i],
                        "Odd packing mismatch at element {}, lane {}", i, lane
                    );
                }
            }
        }

        #[test]
        fn proptest_pack_fn_into(
            _seed in any::<u64>()
        ) {
            // Pack using a function that generates predictable values
            let mut dest = [PackedF::ZERO; 8];
            pack_fn_into::<4>(&mut dest, 3, |elem_idx, lane_idx| {
                F::from_u64((elem_idx * 100 + lane_idx) as u64)
            });

            // Verify
            for i in 0..4 {
                for lane in 0..PackedF::WIDTH {
                    let expected = F::from_u64((i * 100 + lane) as u64);
                    prop_assert_eq!(
                        dest[3 + i].as_slice()[lane],
                        expected,
                        "pack_fn_into mismatch at element {}, lane {}", i, lane
                    );
                }
            }
        }
    }
}
